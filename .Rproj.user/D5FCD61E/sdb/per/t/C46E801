{
    "contents" : "#' Learn from the training data so that later you can fill in missing data\n#'\n#' Like Amelia, FastImputation assumes that the columns of the data are\n#' multivariate normal or can be transformed into approximately\n#' multivariate normal.\n#' \n#' @param x Dataframe containing training data. Can have incomplete rows.\n#' @param constraints A list of constraints.  See the examples below for formatting details.\n#' @return An object of class 'FastImputationPatterns' that contains\n#'   information needed later to impute on a single row.\n#' @export\n#' @seealso \\code{\\link{FastImputation}}\n#' @references\n#' \\url{http://gking.harvard.edu/amelia/}\n#' @author Stephen R. Haptonstahl \\email{srh@@haptonstahl.org}\n#' @examples\n#'\n#' data(FItrain)   # provides FItrain dataset\n#' patterns <- TrainFastImputation(FItrain)\n#'\n#' patterns.with.constraints <- TrainFastImputation(\n#'   FItrain,\n#'   constraints=list(list(1, list(set=0:1)),\n#'                    list(2, list(lower=0)),\n#'                    list(3, list(lower=0)),\n#'                    list(4, list(lower=0)),\n#'                    list(5, list(lower=0)),\n#'                    list(6, list(lower=0, upper=1)),\n#'                    list(7, list(lower=0)),\n#'                    list(8, list(lower=0))))\nTrainFastImputation <-\nfunction(\n  x,\n  constraints=list()\n) {\n  # TODO:\n  # - add idvars parameter such that: a vector of column numbers or \n  #   column names that indicates identification variables.  These \n  #   will be dropped from the analysis but copied into the imputed \n  #   datasets.\n\n  if( \"data.frame\" != class(x) ) stop(\"Training data must be in a data.frame\")\n  \n  x <- UnfactorColumns(x)  # unfactor the columns\n  \n  # Fill the constraints so there is a constraint entry for each column\n  if( 0==length(constraints) ) {\n    filled.constraints <- replicate(ncol(x), list())\n  } else {\n    filled.constraints <- sapply(1:ncol(x), function(i.col) {\n      is.each.constraint.for.this.col <- sapply(constraints, function(this.cons) {\n        return( this.cons[[1]] == i.col )\n      })\n\n      if( 0 == sum(is.each.constraint.for.this.col) ) {\n        return( list() )\n      } else if( 1 == sum(is.each.constraint.for.this.col) ) {\n        return( constraints[[which(is.each.constraint.for.this.col)]][[2]] )\n      } else {\n        return( constraints[[max(which(is.each.constraint.for.this.col))]][[2]] )\n      }\n    })\n  }\n  \n  # Tally the columns with each type of constraint\n  cols.bound.to.intervals <- which(sapply(filled.constraints, function(this.cons) \n    !(is.null(this.cons$upper) && is.null(this.cons$lower))))\n  cols.bound.to.sets <- which(sapply(filled.constraints, function(this.cons) \n    !is.null(this.cons$set) ))\n  \n  # Normalize variables bounded to an interval\n  for(this.col in cols.bound.to.intervals) {\n    x[,this.col] <- NormalizeBoundedVariable(x[,this.col], constraints=filled.constraints[[this.col]])\n  }\n  \n  FastImputationMeans <- colMeans(x, na.rm=TRUE)\n  FastImputationCovariance <- CovarianceWithMissing(x)\n  \n  patterns <- list(FI.means=FastImputationMeans, \n    FI.covariance=FastImputationCovariance, \n    FI.constraints=filled.constraints, \n    FI.cols.bound.to.intervals=cols.bound.to.intervals,\n    FI.cols.bound.to.sets=cols.bound.to.sets)\n  class(patterns) <- \"FastImputationPatterns\"\n  return( patterns )\n}\n",
    "created" : 1385342922507.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2970668800",
    "id" : "C46E801",
    "lastKnownWriteTime" : 1385343034,
    "path" : "~/GitHub/FastImputation/dev/FastImputation/R/TrainFastImputation.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}