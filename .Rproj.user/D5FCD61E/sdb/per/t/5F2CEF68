{
    "contents" : "#' Use the pattern learned from the training data to impute (fill in good guesses for) missing values.\n#'\n#' Like Amelia, FastImputation assumes that the columns of the data are\n#' multivariate normal or can be transformed into approximately\n#' multivariate normal.\n#' \n#' @param x Vector, matrix, dataframe, or object that can be coerced into a dataframe, possibly with some missing (\\code{NA}) values.\n#' @param patterns An object of class 'FastImputationPatterns' generated by \\code{TrainFastImputation}.\n#' @param verbose If TRUE then the progress in imputing the data will be shown.\n#' @return An object of class 'FastImputationPatterns' that contains\n#'   information needed later to impute on a single row.\n#' @export\n#' @seealso \\code{\\link{TrainFastImputation}}\n#' @references\n#' \\url{http://gking.harvard.edu/amelia/}\n#' @author Stephen R. Haptonstahl \\email{srh@@haptonstahl.org}\n#' @examples\n#' data(FItrain)   # provides FItrain dataset\n#' patterns <- TrainFastImputation(FItrain)\n#' \n#' data(FItest)\n#' FItest          # note there is missing data\n#' imputed.data <- FastImputation(FItest, patterns)\n#' imputed.data    # good guesses for missing values are filled in\n#'\n#' data(FItrue)\n#' imputation.rmse <- sqrt(sum( (imputed.data - FItrue)^2 )/sum(is.na(FItest)))\n#' imputation.rmse\nFastImputation <-\nfunction(\n  x,\n  patterns,\n  verbose=TRUE\n) {\n  if( missing(patterns) ) {\n    stop(\"A 'patterns' object must be specified.\")\n  } else {\n    if( class(patterns) != \"FastImputationPatterns\" ) stop(\"'patterns' must be of class 'FastImputationPatterns'. This is generated by appropriate use of the 'TrainFastImputation' function.\")\n  }\n  if( is.vector(x) && is.numeric(x) ) x <- as.data.frame(t(x))\n  if( !is.data.frame(x) && is.matrix(x) ) x <- as.data.frame(x)\n  if( !is.data.frame(x) ) stop(\"'x' must be a vector, matrix, or dataframe.\")\n  \n  n.cols <- length(patterns$FI.means)\n  n.rows <- nrow(x)\n  \n  if(verbose) pb <- txtProgressBar(style=3)\n  \n  for(i.row in 1:n.rows) {\n    # Transform present data if constrained to an interval\n    constrained.row <- x[i.row,]\n    for(i in patterns$FI.cols.bound.to.intervals) {\n      if( !is.na(constrained.row[i]) ) {\n        constrained.row[i] <- NormalizeBoundedVariable(\n          x=constrained.row[i],\n          constraints=patterns$FI.constraints[[i]])\n      } \n    }\n  \n    # Use formula for mean here: http://en.wikipedia.org/wiki/Multivariate_normal_distribution#Conditional_distributions\n    cols.to.impute <- which(is.na(constrained.row))    # indices of \"1\" in Wikipedia formula for mean of conditional multivariate normal distribution\n    if( length(cols.to.impute) > 0 ) {\n      if( length(cols.to.impute) == constrained.row ) {\n        replacement.values <- patterns$FI.means\n      } else {\n        known.cols <- setdiff(1:n.cols, cols.to.impute)  # incides of \"2\" in Wikipedia formula for mean of conditional multivariate normal distribution\n        \n        replacement.values <- t(t(patterns$FI.means[cols.to.impute])) + \n          patterns$FI.covariance[cols.to.impute,known.cols, drop=FALSE] %*% \n          solve(a=patterns$FI.covariance[known.cols,known.cols], \n                b=t(constrained.row[known.cols]) - t(t(patterns$FI.means[known.cols])))\n      }\n      # Store replacement values (note that constraints are not yet applied)\n      x[i.row,cols.to.impute] <- replacement.values ### PERHAPS ADD as.vector to RHS\n    \n      # Constrain interval cols\n      imputed.cols.constrained.to.intervals <- intersect(patterns$FI.cols.bound.to.intervals, cols.to.impute)\n      for(i in imputed.cols.constrained.to.intervals) {\n        x[i.row, i] <- BoundNormalizedVariable(x[i.row, i], constraints=patterns$FI.constraints[[i]])\n      }\n    \n      # Constrain set cols\n      imputed.cols.constrained.to.sets <- intersect(patterns$FI.cols.bound.to.sets, cols.to.impute)\n      for(i in imputed.cols.constrained.to.sets) {\n        x[i.row, i] <- LimitToSet(x[i.row, i], set=patterns$FI.constraints[[i]]$set)\n      }\n    }\n    if(verbose) setTxtProgressBar(pb, i.row/n.rows)\n  }\n  if(verbose) { \n    close(pb)\n    cat(\"\\n\")\n  }\n  return(x)\n}\n",
    "created" : 1369069058526.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1251050891",
    "id" : "5F2CEF68",
    "lastKnownWriteTime" : 1369069414,
    "path" : "~/GitHub/FastImputation/dev/FastImputation/R/FastImputation.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}